### jvm的组成部分
- 包含两个子系统和两个组件(类装载子系统，执行引擎子系统， 运行时数据区组件， 本地接口组件)
- 运行时数据区(jvm内存)分为5部分：
    - 程序计数器 
        当前线程所执行的’字节码的行号指示器‘，’字节码解析器‘的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令
    - 虚拟机栈
       每个方法被执行的时候都会创建一个栈帧，完整的栈帧包括局部变量表、操作数栈、动态连接信息、方法正常完成出口和异常完成信息
       - 堆和栈的区别
         1. 最主要的区别就是栈内存用来存储局部变量和方法调用。堆内存用来存储Java中的对象
         2. 栈内存独享，堆内存共享
         3. 如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。
            而如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。
         4. 栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满
       - 栈溢出
         1. 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError
         2. 如果虚拟机在扩展栈时无法申请到足够的内存空间，将抛出OutOfMemoryError.
             虚拟机动态扩展就是在栈空间不够的时候，自动加大栈的空间，避免StackOverflow
    - 本地方法栈，
       本地方法栈则是为虚拟机使用到的Native方法服务。例如java与mysql交互，底层就是jvm调用自己的本地方法接口，JNI.
    - 堆（新生代，老生代）
       各个线程共享的内存区域
    - 方法区（方法区被称为永久代,内含运行常量池）
       各个线程共享的内存区域，它用于存储JIT即时编译器编译后的代码等数据：已被虚拟机加载的类信息、常量、静态变量。
      
### 垃圾回收算法
- 1.标记清除
    1.标记阶段首先通过根节点(GC Roots)，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。
    2.清除阶段，清除所有未被标记的对象
    3.存活对象较多的情况下比较高效
- 2.复制算法
    1.从根集合节点进行扫描，标记出所有的存活对象，并将这些存活的对象复制到一块儿新的内存
- 3.标记整理
     先标记，后压缩，最后清除
- 4.分代收集算法
  - 在不同年代使用不同的算法，从而使用最合适的算法
     - 新生代存活率低，可以使用复制算法。   Minor GC方式，速度快、效率高的
         新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区
     - 老年代对象存活率搞，没有额外空间对对象进行分配担保，所以只能使用标记清除或者标记整理算法。 Full GC
           
### 垃圾回收器
- 年轻代的垃圾回收器：
   - serial 单线程收集器， 单线程收集器，在进行垃圾收集时，必须暂停其他所有的工作线程
   - parNew 是serial的多线程版本(使用中)
   - parallel-scavenge 是用在计算等吞吐量应用上的第一种选择
- 老年代的回收器
   - serial-old 是老年代的单线程收集器
   - parallel-old是parallel-scavenge 在老年代的中版本，他俩经常一起使用。
   - cms(并发标记清除回收器) ：
       - 目标
          以牺牲吞吐量为代价来获得最短回收停顿时间，适用于要求响应速度的应用。
       - 工作流程：  
         0. 初始标记(stw)、并发标记、并发预先清除、并发可能失败的预先清除、重新标记(stw)、并发清除 
         1. 初始标记：标记直接被GC root引用或被年轻代存活对象所引用的所有对象
         2. 并发标记：根据上个阶段找到GC ROOTS遍历查找，标记所有存活的对象。 (与用户线程并发运行的过程)
         3. 重新标记：标记老年代所有的存活对象。由于之前的阶段是并发执行的，GC线程可能跟不上应用程序的变化，
             为了完成标记老年代所有存活对象的目标，STW就非常有必要了
         4. 并发清除： 与用户的应用程序并发运行
       - 优点：
            并发收集、低停顿。 
       - 缺点：
              1.CPU资源敏感(多核时影响较小)
                 CMS在收集与应用线程会同时会增加对堆内存的占用.CMS必须要在老年代堆内存用尽之前完成垃圾回收；
                 否则CMS回收失败时，将触发担保机制，serial-old将会以STW的方式进行一次GC，从而造成较大停顿时间
              2.无法处理浮动垃圾（Floating Garbage），即无法收集并发运行中产生的新的垃圾。 
                 - 浮动垃圾定义
                    并发清理阶段，工作线程和垃圾回收线程并发工作的时候，此时工作线程会不断产生新的垃圾，
                    但是垃圾回收线程并不会去处理这些新生成的垃圾对象，需要等到下次垃圾回收的时候才会去处理，这些垃圾对象称之为：浮动垃圾 
                 - 结果：
                    1. 因为浮动垃圾的存在，老年代不能在100%使用的时候才去进行垃圾回收，否则就放不下浮动垃圾                       
                    2. 放不下浮动垃圾时会产生Concurrent Mode Failure问题。此时系统会直接使用Serial Old垃圾回收器取代CMS垃圾回收器，
                       从头开始进行GC Roots追踪对象，并清理垃圾，这样会导致整个垃圾回收的时间变得更长。
              3.容易产生空间碎片。并发清理的阶段产生大量的内存碎片. 为了解决这个问题，
                  - +UserCmsCompactAtFullCollection（default=on）这个过程是无法并发的，所以每隔一段时间就会出现停顿时间稍长的问题。
                  - +XX:CMSFullGCsBeforeCompaction，（default=0，每次Full GC时都进行碎片整理）。
   - g1 垃圾收集器(最大特点：可以设置 ‘预期停顿时间’，G1全权负责达到这个目标，控制回收对性能的影响)
      - 目标
         面向服务端应用的垃圾收集器，目标是替换cms；
      - 工作流程：
         1. 初始标记(stop the world)
              比较GC Roots直接引用的对象同时标记,同时标记GC Roots对象所在的Region称为Root Region
         2.根分区扫描
              扫描整个老年代Region的Rset,标记包含初始标记阶段的Root Region的Region.Rset是一个空间换时间的数据结构(避免对整个堆进行扫描),每个Region都包含一个Rset,记录了哪些Region对当前Region的引用。
         3.并发标记
              遍历根分区扫描步骤标记好Region,标记所有可达对象,和应用线程并发执行
         4.重新标记(stop the world)
              由于并发标记是和应用线程并发执行的,所以不可避免的有些对象会发生变化,G1 GC清空 SATB缓冲区，跟踪未被访问的存活对象，并执行引用处理。
         5.选择清除(stop the world)
              评估每个Region的垃圾量,选取回收效果最好的若干Region收集(取决于-XX:MaxGCPauseMillis设置值,默认是200ms)。
              在规定停顿时间内,获取最大的吞吐量。
      - 垃圾回收的种类
         1. young gc

         2. mixed gc
              全部的新生代 + 部分老年代
         3. full gc
      - 优点
          1. 并行和并发
          2. G1可以不需要其它收集器配合就能独立管理整个GC堆,包括新生代和老年代
          3. 空间整合，没有内存碎片产生.
              G1从整体来看是基于“标记-整理”算法实现收集，从局部（两个Region）上来看是基于“复制”算法实现(都不会产生碎片)
          4. 可预测的停顿
              用户可以自定义停顿时间，那么G1就可以对部分的region进行回收！这使得停顿时间是用户自己可以控制的,
              指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒
            在最后筛选回收阶段，对每个region里的回收对象价值（回收该区域的时间消耗和能得到的内存比值）最后进行排序,根据用户
            自定义的停顿时间进行垃圾回收。
          4.1 可以根据用户设置的暂停时间目标自动调整年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大
      - g1中的重要概念
          1. Region。
             堆被分为不同的region， region可以是eden区，suvivor区，old区等，根据需要自行调整。
             它采用分而治之，部分收集的思想，尽力达到我们给它设定的停顿目标。
             在G1中，老年代和新生代逐渐变成逻辑上的概念了(被分配到新对象的Region就是属于年轻代，慢慢的，随着对象的增多，就触发了GC，存活的对象就会被分配到其他空闲的Region，此时这些Region就归属于老年代)
          2. 安全点与安全区域
              安全点：GC要暂停业务线程，并不是抢占式中断(立马把业务线程中断)而是主动中断。
                     主动式中断是设置一个中断标志，各业务线程在运行过程中会不停的主动去轮询这个标志，
                     一旦发现中断标志为True,就会在自己最近的“安全点”上主动中断挂起。
                     用户线程暂停后，GC线程要开始工作，但是要确保用户线程暂停的这行字节码指令是不会导致引用关系的变化，
                     所以JVM会在字节码指令中，选一些指令，作为“安全点”，比如方法调用、循环跳转、异常跳转等。
              安全区域：要是业务线程都不执行（业务线程处于Sleep或者是Blocked状态），那么程序就没办法进入安全点，
                      对于这种情况，就必须引入安全区域。安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，
                      因此，在这个区域中任意地方开始垃圾收集都是安全的。
- 新版本的垃圾回收期
  - ZGC： jdk11中新版垃圾回收器(低延迟垃圾回收器)
  - shenandoah：JDK12中新版垃圾回收器(与 G1 类似，基于 Region 设计的垃圾收集器，但不需要 Remember Set或者Card Table 来记录跨 Region 引用)

### g1垃圾回收器的面试题
1.ParNew + CMS的组合让我们有哪些痛点？
     痛点：STW，且停顿时间不可控
    G1垃圾回收器比~更好的垃圾回收性能
2. G1和CMS的区别
    1.算法不同： G1采用标记-整理算法,CMS采用标记-清除算法,所以G1不会产生很多垃圾碎片.
    2.stw不一样：G1的STW(stop the world)可控,可以使用-XX:MaxGCPauseMillis设置默认200ms
    3.工作模式：G1的Young GC模式可以工作在年轻代,而单独的CMS只能工作在老年代
3.G1是如何做到对垃圾回收导致的系统停顿可控的？
    1-通过把内存拆分为大量小Region。
    2-追踪每个Region的回收价值 - 有多少垃圾、回收这些垃圾预估耗时多少。
    3-在设置的垃圾回收时间内，选择回收价值最好的进行回收
4.尽量控制在指定的时间范围，请问会存在回收时间超时的现象么？几乎不会
5.如果在指定的时间内，回收的空间满足不了新对象的空间需求会怎样？
   继续触发回收,并不会发生oom
6. Region可能属于新生代也可能属于老年代
   新生代和老年代各自的内存区域是不停的变动的，由G1自动控制。
7. G1收集器中大对象怎么分配
     对象的大小<0.5个RegionSize直接存在新生代Eden Region区
     对象的大小>=0.5个RegionSize且对象的大小<1个RegionSize,存到大对象区Humongous Region
     对象的大小>=1个RegionSize存到连续的大对象区Humongous Region

### 如何判断一个对象是否可以被回收？
- 引用计数法  很难解决对象之间的循环引用问题
- 枚举根节点做可达性分析
    通过一系列名为“GC Roots”的对象作为起始点，从“GC Roots”对象开始向下搜索，
    如果一个对象到“GC Roots”没有任何引用链相连，说明此对象可以被回收。

### 哪些对象可以作为 GC Roots 的对象：
* 虚拟机栈中局部变量（也叫局部变量表）中引用的对象
* 方法区中类的静态变量、常量引用的对象
* 本地方法栈中 JNI (Native方法)引用的对象 

### 什么是full gc
1. gc包括minor gc， major gc， full gc
2. full gc就是这次GC的全过程都是Stop-The-World的。(major gc 有两个阶段是stw的，但不是full gc)

### 触发fullGC的条件
- 1.System.gc  
      可能触发fullGc
- 2.旧生代空间不足
      - 创建大对象直接进入旧生代，旧生代空间不足时，
      - concurrent mode failure
        在执行CMS GC的过程中同时业务线程把对象要放入旧生代，而此时旧生代空间不足造成的。
        该失败会触发担保机制，CMS临时采用serial-old进行垃圾清除，STW的方式
- 3. Minor GC时
      4.1 promotion failed：
        在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；
      4.2 空间分配担保机制失败
       在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。
       如果这个条件成立，那么Minor GC可以确保是安全的。
       如果不成立，则虚拟机会查看HandlerPromotionFailure设置是否允许担保失败。
       如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。
       如果大于，将尝试着进行一次Monitor GC，尽管这次GC是有风险的。
       如果小于，或者HandlerPromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC了。     
- 4.JDK 1.7 及以前的永久代空间不足

### 导致oom的情况：
1. 堆不够用：内存泄漏 / 请求创建一个超大对象 / 栈在动态扩展时找不到足够内存
    java.lang.OutOfMemoryError：Java heap space
2. 当Java进程花费98%以上的时间执行GC，但只恢复了不到2%的内存，且该动作连续重复了5次
     java.lang.OutOfMemoryError:GC overhead limit exceeded 
3. Unable to create new native thread
   - 问题发生的常见过程主要包括以下几步：   
    1. JVM 内部的应用程序请求创建一个新的Java线程；
    2. JVM native方法代理了该次请求，并向操作系统请求创建一个 native 线程；
    3. 操作系统尝试创建一个新的 native 线程，并为其分配内存；
    4. 如果操作系统的虚拟内存已耗尽，或是受到32位进程的地址空间限制，操作系统就会拒绝本次native内存分配；
    5. JVM 将抛出 java.lang.OutOfMemoryError:Unableto createnewnativethread 错误。
   - 解决方式
    1. 操作系统设置了应用创建线程的最大数量，并且已经达到了最大允许数量(操作系统线程+jvm线程)
         调高OS层面的线程最大数：执行ulimia-a查看最大线程数限制，使用ulimit-u xxx调整最大线程数限制。
         ps -hH 进程号 | wc -l命令统计jvm有多少线程。
    2. 由于线程使用的资源过多，操作系统已经不能再提供给应用资源了。
         所以升级配置，为机器提供更多的内存；
         1. 最大线程数 = （操作系统最大可用内存 - JVM内存 - 操作系统预留内存）/ 线程栈默认1M
4. oom killer
    1. 默认情况下，Linux内核允许进程申请的内存总量大于系统可用内存，
       通过这种“错峰复用”的方式可以更有效的利用系统资源。
    2. 这种方式也会无可避免地带来一定的“超卖”风险。例如某些进程持续占用系统内存，然后导致其他进程没有可用内存。
       此时，系统将自动激活OOM Killer，寻找评分低的进程，并将其“杀死”，释放内存资源。
5. Direct buffer memory
   - 原因分析
    Direct ByteBuffer默认大小为64MB，一旦使用超出限制，就会抛出Directbuffer memory错误。
   - 解决方案
    1. 检查是否直接或间接使用了 NIO，如 netty，jetty 等
    2. Java只能通过ByteBuffer.allocateDirect方法使用Direct ByteBuffer，检查有没有这个
    3. 通过启动参数 -XX:MaxDirectMemorySize 调整 Direct ByteBuffer 的上限值。
6. 数组太大
   - 原因 
   JVM在为数组分配内存前，会检查要分配的数据结构在系统中是否可寻址，通常为 Integer.MAX_VALUE-2。
   超过会报Requested array size exceeds VM limit
7. 永久代oom
    调大参数。
      
### jvm中内存分配策略
分配原则是： 
1. 优先分配在Eden区(Eden区内存不足的时候，会执行一次Minor GC)
2. Eden区-->Servivor区-->老年区(当Servivor区有足够的空间就放置在Servivor区，否则放置于老年区。)
3. 长期存活的对象将进入老年代(当对象的年龄超过这个值后，它就晋升到老年代中。默认是15. )

### jvm中对象的创建
- 流程： 类是否加载--> 内存是否规整 --> 并发问题 --> 对象设置
1. 单线程时分配策略：
   如果堆中内存是绝对规整的，使用“指针碰撞“方式分配内存；
   如果不是规整的，就从空闲列表中分配，叫做”空闲列表“方式。( Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能)
2.多线程时分配策略:
    2.1. CAS同步处理，(堆是共享的,在堆上分配有锁的开销)
    2.2 本地线程分配缓冲(Thread Local Allocation Buffer, TLAB，需要开启 -XX:useTLAB).
       JVM在内存新生代Eden Space中开辟了一小块线程私有的区域，称作TLAB。默认设定为占用Eden Space的1%。
       小对象通常JVM会优先分配在TLAB上。(1. TLAB上的分配由于是线程私有所以没有锁开销。2.Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC)
       因此在实践中分配多个小对象的效率通常比分配一个大对象的效率要高。      
3.然后内存空间初始化操作
4.接着是做一些必要的对象设置(元信息、哈希码…)，
5.最后执行<init>方法。

- jvm中对象不一定都是在堆上分配的。
1. 如果没有指针逃逸，那么对象可能分配到栈内存上.
    指针（或者引用）的逃逸：当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他过程或者线程所引用，
2. TALB分配。分配到栈上。



### jvm中对象的访问定位
- Java程序需要通过JVM栈上的引用访问堆中的具体对象。对象的访问方式取决于 JVM 虚拟机的实现。访问方式有:句柄和直接指针
   - 指针：指向对象，代表一个对象在内存中的起始地址。
           优势：速度更快，节省了一次指针定位的时间开销。HotSpot 中采用的就是这种方式。
   - 句柄：可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。
           优势：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。
           
### jvm中类加载机制
- 概述：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。
- 动态加载： Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，
           至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。
- 主要有一下四种类加载器:
    启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。
    扩展类加载器(extensions class loader):它用来加载Java的扩展库。\lib\ext目录
    系统类加载器（system class loader）：它根据Java应用的类路径（CLASSPATH）来加载 Java 类。通过ClassLoader.getSystemClassLoader()来获取它。
    用户自定义类加载器： 通过继承 java.lang.ClassLoader类的方式实现。
       - 为什么需要用户自定义？
           Java中提供的默认ClassLoader，只加载指定目录下的jar和class(classPath路径下)，如果我们想加载其它位置的类或jar时，需要自定义。
       - 如何自定义类加载器
            1、继承java.lang.ClassLoader      
            2、重写父类的findClass()
- 双亲委派模型：(目的：为了系统类的安全，类似“ java.lang.Object”这种核心类)
    如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，
    这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，
    子加载器才会尝试去加载类。
- 类加载过程
     加载(导入class文件)--> 验证--> 准备(给类中的静态变量分配内存空间) --> 解析(符号引用替换成直接引用) --> 初始化(clinit，为类的静态变量赋初值)
- 类初始化时机clinit
    1. new对象，调用 static方法，static变量时；
    2. 反射生成对象时
    3. 初始化一个类时，先初始化父类；
    4. 虚拟机启动时，Main类会初始化。
- 类不会初始化的时机
    1. 子类引用父类的静态变量，只会初始化父类，不会初始化子类；
    2. ClassLoader.loadClass(className)，只加载和连接,不会进行初始化(自己试一下)
    3. 常量池中的常量使用不会导致初始化
    4. 通过数组定义来引用类，不会触发此类的初始化(数组类本身不通过类加载器创建，而是由Java虚拟机直接创建的)
- 类加载方式: 
   1.隐式装载: 
       程序在运行过程中当碰到通过new等方式生成对象时，隐式调用类装载器加载对应的类到jvm中
   2.显示装载：
       Class.forName("Persion");
       ClassLoader.loadClass(className)
- clinit VS init  (在编译生成class文件时，编译器会产生两个方法加于class文件中，一个是类的初始化方法clinit, 另一个是实例的初始化方法init。)
    1.clinit指的是类构造器，主要作用是在类加载过程中的初始化阶段进行执行，执行内容包括静态变量初始化和静态块的执行。
       - 如果类中没有静态变量或静态代码块，那么clinit方法将不会被生成。
       - clinit只在类加载阶段执行一次；
    2.init指的是实例构造器，主要作用是在类实例化过程中执行，执行内容包括成员变量初始化和代码块的执行。
       - 每次实例化都执行一次；

- JDBC破坏双亲委派模型
0.背景：java在rt.jar中提供了数据库接口访问：driver接口和driverManager管理driver接口，是由启动类加载器加载的。
1.不破坏双亲委派方式：手写jdbc
 Class.forName("com.mysql.jdbc.Driver"); // // 1.加载数据访问驱动
这个其实触发了静态代码块，然后向DriverManager中注册了一个mysql的Driver实现。
2. 破坏双亲委派的方式：(Service Provider Interface,是Java提供的一套用来被第三方实现或者扩展的接口,它可以用来启用框架扩展和替换组件。)
2.1. 使用spi的方式来注册mysql的Driver：具体做法就是在mysql的jar包中的
  META-INF/services/java.sql.Driver 文件中指明当前使用的Driver是哪个；
2.2. spi服务的调用过程：
第一，从META-INF/services/java.sql.Driver文件中获取具体的实现类名“com.mysql.jdbc.Driver”
第二，加载这个类，这里肯定只能用class.forName("com.mysql.jdbc.Driver")来加载
2.3. spi问题：
Class.forName()加载用的是调用者的Classloader，这个调用者DriverManager是在rt.jar中的，
ClassLoader是启动类加载器，而com.mysql.jdbc.Driver肯定不在<JAVA_HOME>/lib下，
所以肯定是无法加载mysql中的这个类的。这就是双亲委派模型的局限性了，父级加载器无法加载子级类加载器路径中的类。
2.4 解决方式(打破双亲委派)
这个mysql的drvier只有应用类加载器能加载，那么我们只要在启动类加载器中有方法获取应用程序类加载器，
然后通过它去加载就可以了。这就是所谓的线程上下文加载器。
Thread.setContextClassLoaser()方法设置，如果不特殊设置会从父类继承，一般默认使用的是应用程序类加载器

       
### java 内存模型(Java Memory Model，JMM)
- 由java虚拟机规范定义，用来屏蔽掉不同的硬件和操作系统对内存的访问的差异，来能达到"内存访问的一致性"
- Java内存模型的主要目标：定义程序中变量的访问规则。
     在虚拟机中将变量存储到主内存或者将变量从主内存取出这样的底层细节。
     变量是指实例字段，静态字段，构成数组对象的元素，但是不包括局部变量和方法参数(因为这是线程私有的)
- Java内存模型中涉及到的概念
   - 主内存： java虚拟机规定所有的变量(不是程序中的变量)都必须在主内存中产生(为了方便理解，可以认为是堆区)
   - 工作内存：java虚拟机中每个线程都有自己的工作内存，该内存是线程私有的为了方便理解(可以认为是虚拟机栈。)
             虚拟机规定，线程对主内存变量的修改必须在线程的工作内存中进行，不能直接读写主内存中的变量。
- java虚拟机中主内存和工作内存交互
    - 一个变量如何从主内存传输到工作内存中，如何把修改后的变量从工作内存同步回主内存。
    - 定义了8中原子操作：
       - 主内存中： lock， unlock；  write(接store，修改变量)
       - 工作内存中： read(读取主内存变量)， load(保存变量副本)，use， assign(赋值)，store(传递工作内存变量到主内存中，为write准备)
    - 对于普通变量，虚拟机只是要求原子操作的顺序的执行，并没有要求连续的执行
    - 执行8种原子操作必须遵循的规则
        1. 变量只能在主内存中产生
        2. 不允许read和load、store和write操作之一单独出现
        3. 不允许一个线程丢弃最近的assign操作; 不允许一个线程没有assign时，回写没有修改的变量到主内存
        4. 一个变量在同一时刻只能被一个线程对其进行lock操作；
          lock时，就会清空工作空间该变量的值；
          不允许对没有lock的变量执行unlock操作；
          unlock之前，必须先把变量同步回主内存中
- 并发内存模型的实质
  Java内存模型围绕着并发过程中如何处理原子性、可见性和顺序性这三个特征来设计的。
- 先行发生原则
  先行发生原则是Java内存模型中定义的"两个操作之间的偏序关系"。比如说操作A先行发生于操作B，那么在B操作发生之前，
  A操作产生的“影响”都会被操作B感知到。这里的影响是指修改了内存中的共享变量、发送了消息、调用了方法等。
  个人觉得更直白一些就是有可能对操作B的结果有影响的都会被B感知到，对B操作的结果没有影响的是否感知到没有太大关系。
  
### jvm中对象结构
1. 对象头：包括两部分：mark-word(hashcode, )， 指向类元数据的指针
2. 数据区域
3. 对齐填充

### 引用  强> 软> 弱  >虚
- 软引用
   在jvm内存不足时才会回收
- 弱引用
   在jvm进行垃圾回收时就会回收

SoftReference<String> softRef=new SoftReference<String>(str);软引用可用来实现内存敏感的高速缓存。
WeakReference<String> abcWeakRef = new WeakReference<String>(str);

### 常用的命令
- jstat 实时显示jvm进程中的各种情况
     命令格式：
        jstat -gcutil pid timesInterval showCounts
        显示gc相关信息百分比(包括堆区各个分代的容量，使用大小，gc次数和gc时间等)

- jstack 线程快照，显示线程正在执行的方法,可定位长时间停顿的原因，或线程死锁，cpu过高等。
     命令格式:jstack [option] pid (-F:force, -l:lock信息)

- jmap 显示堆和永久代的详细信息
     - 常用命令
       jmap -heap pid  显示堆信息
       jmap -dump:live,format=b,file=m.hprof PID    下载文件
       jmap -histo:live pid | head -n 10 统计对象大小

- 导出异常内存文件 dump
1. 内存溢出时让其自动生成： 配置jvm参数-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/biapp/m.hprof
2. 在没有hprof文件下强制导出: jmap -dump:live,format=b,file=m.hprof PID
