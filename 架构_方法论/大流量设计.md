### 设计的基本原则
- ![高并发](../picture/高并发解决.jpg)
    1. 成套方案手段
        1.1. 服务拆分，服务化
        1.2. 消息队列来解耦，异步
        1.3. 缓存提高性能
        1.4. 数据库分库分表
    2. 技术手段：
        2.1 池化技术
               线程池/连接池/对象池/内存池
        2.2 异步化
               异步化future
        2.1 预处理和延后处理
               延后处理还有一个非常著名的例子，fork子进程时，不复制主进程的数据区
        2.4 批量处理
               提供批量接口/合并请求
        2.5 无锁化编程
                cas/ copy on write / 原子计数器
- 高可用
   - 集群
   - 限流
   - 熔断降级
      1. 自动开关降级(开关：超时，统计失败次数，故障，限流)
      2. 人工降级
      3. 读服务降级
      4. 写服务降级
      5. 多级降级
- 业务设计
   - 幂等
  
### 高可用
1. 熔断降级(高可用)
    - 降级是针对于整体服务，整体负荷超出整体负载承受能力时，延迟或暂停非重要服务，例如日志收集服务
    - 熔断针对于单个服务，当某一服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施
2. 限流(高可用)
   -  QPS限流算法：
       1. 固定窗口计数器： 
            规定单位时间处理的请求数量，到时间重新开始。
            这种限流算法无法保证限流速率，因而无法保证突然激增的流量
       2. 滑动窗口计数器： 固定窗口的优化：把时间以一定比例分片，
            例如我们的接口限流每分钟处理600个请求，我们可以把1分钟分为60个窗口。
            每隔1秒移动一次，每个窗口一秒只能处理不大于10次的请求， 如果超过10次就不再处理。
       3. 漏桶算法(消费端，即出水口是恒定的)
            可以以任意速率流入水滴到漏桶；如果流入水滴超出了桶的容量，则流入的水滴溢出了被丢，而漏桶容量是不变的。
            强行限制数据的传输速率。
       4. 令牌桶算法(消费端，即拿令牌是允许突发的，如果有多余令牌的化话)
           固定速率生成令牌，消费时有令牌就放行，没有令牌就卡住。
          能够在限制数据的平均传输速率的同时还允许某种程度的突发传输
            - 漏桶算法 VS 令牌桶算法： A服务调用B服务
                 1. 漏桶算法主要用来保护三方的。当B没有保护机制和限流机制时，在A中使用漏桶算法。
                 2. 令牌桶算法主要是保护自己的。在B中使用令牌桶算法，可以对A的调用限流，为的是让自己不被打垮。     
   - 并发数限流算法(hystrix)
       1. 使用信号量限流， 用完返回失败
       2. 使用线程池，线程用完就返回失败
         

### 常见的限流例子
1. NGNIX限流(主要有两种)
     1. 按连接数限流(ngx_http_limit_conn_module)（令牌算法实现）
     2. 按请求速率限流(ngx_http_limit_req_module)（漏桶算法实现）
2. Tomcat 线程池限流(三个配置参数来进行限流操作)
     1. maxThreads（最大线程数）：每一次HTTP请求到达Web服务，tomcat都会创建一个线程来处理该请求，那么最大线程数决定了Web服务可以同时处理多少个请求，默认200.
     2. accepCount（最大等待数）：当调用Web服务的HTTP请求数达到tomcat的最大线程数时，还有新的HTTP请求到来，这时tomcat会将该请求放在等待队列中，这个acceptCount就是指能够接受的最大等待数，默认100.如果等待队列也被放满了，这个时候再来新的请求就会被tomcat拒绝（connection refused）。
     3. maxConnections（最大连接数）：这个参数是指在同一时间，tomcat能够接受的最大连接数。一般这个值要大于maxThreads+acceptCount。
3. 分布式限流
     0. 分布式限流最关键的是要将限流服务做成原子化，
        解决方案可以使使用redis+lua或者nginx+lua技术进行实现
     1.首先我们来使用redis+lua实现时间窗内某个接口的请求数限流，
       实现了该功能后可以改造为限流总并发/请求数和限制总资源数。
       Lua本身就是一种编程语言，也可以使用它实现复杂的令牌桶或漏桶算法。
     2.有人会纠结如果应用并发量非常大那么redis或者nginx是不是能抗得住；
       1. 流量是不是真的有这么大，
       2. 通过一致性哈希将分布式限流进行分片，
       3. 当并发量太大降级为应用级限流；
       4. 京东使用Redis+Lua来限流抢购流量，一般流量是没有问题的。
     
     
     
     