###要解决的问题：
同一时间同时进行抢购，网站瞬时访问流量激增。
访问请求数量远远大于库存数量，但是只有少部分用户能够秒杀成功（高并发访问的数据安全性）。 

-[微信红包的高并发](https://blog.csdn.net/starsliu/article/details/51134473)
- 秒杀活动不适合抢红包场景
   1. 内存数据库替代数据库事务：内存操作完成，数据库保存失败，或内存出现Crash，数据库的存储进程不会进行
   2. 使用乐观锁替代悲观锁： 影响用户体验； 带来大数量的无效更新请求、事务回滚，给DB造成不必要的额外压力。
- 微信红包技术结合电商平台设计的秒杀系统之基础，采用了以下技术解决方案：
   1. SET集合化(按红包Id进行hash路由)
       微信红包系统生成一个ID当它的唯一标识，接下来针对于这个红包的所有发、抢、拆、查询详情等操作都根据这个ID关联。
   红包系统根据这个红包ID，按一定的规则（如按ID尾号取模等），垂直上下切分。切分后，一个垂直链条上的逻辑服务器、服务器统称为一个SET（集合）。
   这样，每个集合间相互独立，互相解耦，不存在任何关联。
   2. 串行化请求队列
       把到达数据的事务操作（拆红包行为）的并发改为串行，由统一一个通道出口，就不会存在“并发抢锁”的问题。
   来把拆红包的事务操作串行地进入数据库，来将请求在服务器层以FIFO（先进先出）的方式排队，就可以达成串行的效果。
   为了防止Server中的请求队列过载导致队列被降级，从而所有请求拥进DB，
   系统增加了与Server服务器同机部署的memcached，用于控制拆同一个红包的请求并发数。
   具体来说，利用memcached的CAS原子累增操作，控制同时进入DB执行拆红包事务的请求数，超过预先设定数值则直接拒绝服务。
   3. 双维度分拆数据库表
       红包系统的分库表规则，初期是根据红包ID的hash值分为多库多表。随着红包数据量逐渐增大，单表数据量也逐渐增加。
   采用冷热分离，将历史冷数据与当前热数据分开存储，可以解决这个问题。增加以循环天分表的维度。
   
   
1. 发红包时的预订单
   支付前订单落cache，同时利用cache的原子incr操作顺序生成红包订单号。优点是cache的轻量操作，以及减少DB废单
2. 拆红包入账异步化
   拆红包时，DB中记下拆红包凭证，然后异步队列请求入账.理论基础是快慢分离

- 高并发：
1. 发红包流量控制。
    1. 发红包是业务流程的入口，控制了这里的并发量，代表着控制了红包业务整体的并发量。
    2. 在发红包的业务链路里，做了多层的流量控制，确保产生的有效红包量级在可控范围。
2. 抢红包控制(微信红包领取时分为两个步骤，抢和拆)。
    1. 抢红包这个动作本身就有控制拆并发的作用。因为抢红包时，只需要查cache中的数据，不需要请求DB。
    2. 对于红包已经领完、用户已经领过、红包已经过期等流量可以直接拦截。
    3. 而对于有资格进入拆红包的请求量，也做流量控制。通过这些处理，最后可进入拆环节的流量大大减少，并且都是有效请求。
3. 拆红包控制：
    对同一个红包的拆请求做原子计数，控制同一时刻能进DB中拆红包的并发请求数。


### 微信红包算法：
