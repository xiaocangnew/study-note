### EDA 与 mq 有什么区别：
1. mq 中的消息是一个抽象的概念。 EDA中的事件是一个具象化的概念，一般情况下，它有一个 Schema 来精准描述事件有哪些字段
2. 从用途上来讲，消息往往用于微服务的异步解耦的架构，事件驱动跟消息是稍微类似的。
    1. 消息的应用场景往往发生在一个组织内部，消息的生产方知道这个消息要将被如何处理，通过文档进行约束。
    2. 相比之下，事件更加松耦合，比如说事件发送方也不知道这个事件将被投递到什么地方，将被谁消费，谁对他感兴趣，对事件被如何处理是没有任何预期的。事件通过schema进行约束。


### 适用场景
>>> 在采用事件驱动架构时，我们需要考虑业务的建模、事件的设计、上下文的边界以及更多技术方面的因素，这个系统工程应该如何从头到尾的落地，是需要经过思考和推敲的。
如果盲目使用事件驱动设计架构，就有可能要承担中断业务逻辑的风险，因为这些业务逻辑具有概念上的高度内聚，却采用了解耦机制将它们联系在一起。
>换句话说，就是将原本需要组织在一起的代码强行分离，并且这样难于定位处理流程，还有数据一致性保证等问题。
> 以经验来讲，以下三 种场景可以使用事件驱动开发：
1. 组件的解耦
2. 执行异步任务
3. 跟踪状态的变化(当业务上无法准确存储数据的变更和修改时间。但是在事件驱动架构中，可以通过事件溯源将包含修改的内容存入到事件里)

### EDA实现的方法和工具：
1. 发布订阅机制
    1. mq
    2. 规则引擎， (规则引擎可以根据事先定义的规则来对事件进行处理和判断)
    3. 响应式框架(响应式框架将事件和数据流结合在一起，通过观察者模式来实现事件的订阅和处理。常见的响应式框架包括Reactor、RxJava等。)
2. 事件流式处理：事件会写入日志。
    事件是（在分区中）经过严格排序的，而且具有持久性。 客户端不会订阅流，但是客户端可以读取该流的任何部分。 
    客户端负责提升它在流中的位置。 这意味着客户端可以随时加入，并可以重播事件。


### 如何保证事件的数据一致性
1. 不可变事件， 2.版本控制。3. 原子事务， 4. 幂等性， 5.最终一致性(异步处理，定期同步)， 6.分布式事务.

### 如何设计事件的处理顺序机制
1. 使用消息队列：消息队列可以保证消息的传递顺序，
2. 引入序列号或时间戳：在发送事件时，为每个事件附加一个唯一的序列号或时间戳。这种方法适用于那些虽然异步但需要保持一定顺序的场景。
3. 事务性保障：对于某些系统，可能需要更强的事务性保障来确保事件的正确顺序。例如，在金融交易系统中，可以使用两阶段提交协议或其他分布式事务管理技术来确保一系列相关操作要么全部成功，要么全部回滚，从而维护事件的处理顺序。
4. 快照与补偿事件：当直接控制事件顺序变得复杂时，可以考虑采用快照机制和补偿事件。即定期保存系统状态的快照，并在检测到顺序错误时，通过发送补偿事件来修正系统的状态，使其回到正确的轨迹上。
5. 分区处理：如果事件可以被归类到不同的类别或分区中，则可以在每个分区内独立地保证事件的处理顺序，而不同分区之间可以并行处理。这样既保证了必要的顺序，又提高了整体处理效率。
6. 依赖关系明确化：有时，确保事件处理顺序的最佳方式是明确地定义事件间的依赖关系。这意味着设计者需要清楚哪些事件必须在其他事件之前发生，并据此调整事件产生和消费的逻辑。

### EDA的存在的问题/挑战：
1. 有保证的传递，(1. 使用可靠的传输协议，2.消息确认机制 3. 快照和补偿)
2. 错误处理。事件驱动的体系结构主要使用异步通信。 异步通信的一个挑战是错误处理。
    1. 死信队列/使用单独的错误处理器。
         比如在订单和库存中间新增一个错误处理器。库存处理订单失败后，扔给错误处理器后继续处理其他订单。
         错误处理器尝试修复错误并重新生成订单事件，否则进行通知认为干预。
    2. 自动重试机制
    3. 回退策略：(防止故障扩散，当检测到连续失败次数超过阈值时，暂时停止向下游服务发送请求一段时间)
    4. 事务补偿，(针对已经部分完成的操作进行反向操作以撤销之前的效果，确保系统的最终一致性)
3. 实现传统的请求响应模式
    0. 基于 Future/Promise 的同步等待
    1. 使用回调机制，事件产生者在发送请求时指定一个回调函数或处理程序，当响应准备好时会调用这个回调。(在线支付系统)
    2. 使用消息队列中的临时队列，扩展性和性能和健壮性高于回调机制，但是更复杂(例如在一个电商平台上，用户提交订单后，平台需要即时验证库存可用性并将结果反馈给用户。当用户提交订单时，订单服务创建一个临时队列并发送包含订单详情的消息到库存服务。库存服务处理完毕后，将结果发送到该临时队列。订单服务监听此队列，一旦收到回复即解除阻塞并向用户展示结果。这使得即使在异步环境中也能保证对用户的快速响应)
4. 调试难度：由于事件是异步处理的，集成调试起来可能会比较困难。
5. 数据一致性：由于事件是异步处理的，EDA模式需要考虑如何保证数据的一致性。
6. 复杂性：EDA模式需要对事件进行发布处理和管理，需要考虑消息传递方式，可靠性，一致性，事件处理的并发，顺序性等，增加复杂度。





eda的例子： 1. 家长端轨迹，  2. 推送通知



### 设计和实现事件驱动的架构需要进行以下几个步骤：
1. 确定事件和事件源：首先，需要确定系统中哪些操作和功能可以作为事件源，并对其进行建模。事件源可以是用户界面的点击事件、传感器数据的更新事件等。
2. 定义事件和消息：根据事件源的建模，需要定义系统中可能发生的事件，并对事件进行分类和定义相应的消息格式。事件中应该包含必要的数据和信息，以便让后续的事件处理器进行处理。
3. 设计事件处理器：根据系统的功能需求和事件的分类，设计事件处理器。事件处理器可以是一个独立的模块，也可以是一个服务。事件处理器应该根据事件的类型和数据，进行相应的处理和操作。
4. 实现事件通道：根据选择的方法和工具，实现事件通道。可以使用消息队列、中间件或规则引擎来实现事件的传递和分发。需要根据事件的类型和订阅关系，将事件分发给相应的事件处理器。
5. 编写事件消费者：编写相应的事件消费者，从事件通道中获取事件，并执行相应的操作。事件消费者应该根据事件的类型和数据进行逻辑的处理，可以调用其他组件或服务进行进一步的操作。
6. 测试和验证：对设计和实现的事件驱动架构进行测试和验证。可以使用模拟的事件源和事件来验证事件的传递和处理是否符合预期，同时测试系统的性能和安全性。



参考文章：
https://baijiahao.baidu.com/s?id=1791796528258228377&wfr=spider&for=pc
https://www.51cto.com/article/711545.html
