### 同步阻塞
同步等待浪费系统资源，且通过分配更多线程来支撑更多请求的方式，会导致上下文切换和锁竞争，拉低资源利用率。
基于一个请求一个线程的服务模式无法做到动态伸缩，难以应对突发流量。

### 异步与反应式
1. 线程池处理请求的问题会导致峰值线程资源耗尽，服务阻塞情况。
2. 使用Reactor模式，通过多路复用分发思想大大减少线程的使用。

### 从callback到future，从Future到Reactive
1. 与Callback相比,CompletableFuture可以避免方法多层嵌套问题
2. 与reactive相比，completableFuture面对相对复杂业务逻辑时仍存在以下局限：
    难以简单优雅实现多异步任务编排；
    难以处理实时流式场景；
    难以支持高级异常处理；
    不支持任务延迟执行。

### Reactive反应式编程
   1. 其本质是面向事件流、基于Reactor模型、可保证服务在任何场景下都能保持实时响应的架构
   2. 在任务处理角度，它基于事件驱动模型（比如Java NIO/Selector）提供任务异步处理能力，在编程模型角度，
        它提供面向事件流的一系列操作组合（Operator），与目前流行的函数式编程、CQRS和EventSourcing相辅相成。
   3. 核心概念
       数据流 + 函数式编程 + 异步观察
- 优势:
1. 在业务层面实现代码逻辑分离,方便后期维护和拓展;
2. 极大的提高程序的响应速度,充分发掘CPU的能力;
3. 帮助开发者提高代码的抽象能力和充分理解业务逻辑;
4. Rx丰富的操作符会帮助我们极大地简化代码逻辑.

- 劣势:
1. 使用复用线程有助于提高吞吐量,但是一旦在某个回调函数中被卡住,,整个线程都会被阻塞,甚至程序被拖垮;
2. 难以调试;
3. 响应式编程是异步编程下的子集;也是一个范式;
4. 响应式编程一般是事件驱动event-driven相比之下,响应式系统是消息驱动Message-dirven的;
     * 响应式编程--专注于短时间的数据流链条上的计算--因此倾向事件驱动;
     * 响应式系统--关注于通过分布式的通信和协作所得到的弹性和韧性--则是消息驱动的.

- 基本要求
1. Responsive:可响应的,要求系统尽可能的在任何时候都能做到及时响应;
2. Resilient:可恢复的,要求系统即使出错了,也要保持可响应性;
3. Elastic:可伸缩的,要求系统在各种负载下都能保持可响应性;
4. Message Driven:消息驱动的.要求系统通过异步消息连接各个组件;

- 响应式编程的关键就是将异步可观查对象模块化. Rx有两种常见模式,一是观察者模式,其二是迭代模式


### Vert.x
 客户端请求数量激增，传统服务器架构已不堪重负，致使基于事件和异步的解决方案备受追捧
 Vert.x框架基于事件和异步，依托于全异步Java服务器Netty，并扩展了很多其他特性，以其轻量、高性能、支持多语言开发而备受开发者青睐。

### reactor模型
- 这个模式是从NIO中出来的，是一种基于事件驱动模型的设计模式。包含
    EventHandler：事件处理器，可以根据事件的不同状态创建不同状态处理器。
    Handler：可以理解为事件，网络编程中为Socket，在数据库中为DBConnection
    InitiationDispatcher：用于管理EventHandler，分发event容器，是一个事件处理器。
    Demultiplexer：阻塞等待Handler中事件的到来。


