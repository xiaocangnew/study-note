### 面向对象建模面临的一个棘手问题是数据边界和行为边界往往不一致。
- 遵循模块化的思想，我们通过类将行为和其紧密耦合的数据封装在一起。但是在复杂的业务场景下，
  行为往往跨越多个领域对象，这样的行为如果放在某一个对象中必然会导致别的对象需要向该对象暴漏其内部状态。
  
- 面向对象发展的后来，领域建模出现两种派别之争
1.一种倾向于将跨越多个领域对象的行为建模在领域服务中。如果这种做法使用过度，
   则会导致领域对象变成只提供一堆get方法的哑对象，这种建模结果被称之为贫血模型。
2.另一种则坚定的认为方法应该属于领域对象，所以所有的业务行为仍然被放在领域对象中，
   这样导致领域对象随着支持的业务场景变多而变成上帝类，而且类内部方法的抽象层次很难一致。
   另外由于行为边界很难恰当，导致对象之间数据访问关系也比较复杂，这种建模结果被称之为充血模型。

### 服务器后端发展三个阶段：
1. UI+DataBase的两层架构，这种面向数据库的架构没有灵活性。
2. UI+Service+DataBase的多层SOA架构，这种服务+表模型的架构易使服务变得囊肿，难于维护拓展，伸缩性能差
3. DDD+SOA微服务的事件驱动的CQRS读写分离架构，应付复杂业务逻辑，以聚合模型替代数据表模型，
    以并发的事件驱动替代串联的消息驱动。真正实现以业务实体为核心的灵活拓展
    
- DDD革命性
1. 领域模型准确反映了业务语言，带有业务方法的‘充血模型’,例如一些逻辑写在Order表中。
2. 传统J2EE或Spring+Hibernate等事务性编程模型只关心数据，
     这些数据对象除了简单setter/getter方法外，没有任何业务方法，被比喻成‘失血模型’，
3. DDD最大的好处是：接触到需求第一步就是考虑领域模型，DDD让你首先考虑的是业务语言，而不是数据。
    而不是将其切割成数据和行为，然后数据用数据库实现，行为使用服务实现，最后造成需求的首肢分离。

- 将数据输送到模型中
  使用事件event
  
### [DDD实践的四层架构](https://www.cnblogs.com/panxixi/p/11792508.html)
1. User Interface为用户界面层（或表示层），负责向用户显示信息和解释用户命令。
    这里指的用户可以是另一个计算机系统，不一定是使用用户界面的人。
2. Application为应用层，定义软件要完成的任务，并且指挥表达领域概念的对象来解决问题。
  这一层所负责的工作对业务来说意义重大，也是与其它系统的应用层进行交互的必要渠道。
  应用层要尽量简单，不包含业务规则或者知识，而只为下一层中的领域对象协调任务，分配工作，使它们互相协作。
3. Domain为领域层（或模型层），负责表达业务概念，业务状态信息以及业务规则。
  尽管保存业务状态的技术细节是由基础设施层实现的，但是反映业务情况的状态是由本层控制并且使用的。
  领域层是业务软件的核心，领域模型位于这一层。 
4. Infrastructure层为基础实施层
  向其他层提供通用的技术能力：为应用层传递消息，为领域层提供持久化机制，为用户界面层绘制屏幕组件，等等。
  基础设施层还能够通过架构框架来支持四个层次间的交互模式。
  
- 在四层架构模式的实践中，对于分层的本地化定义主要为：
1. User Interface层主要是Restful消息处理，配置文件解析，等等。
2. Application层主要是多进程管理及调度，多线程管理及调度，多协程调度和状态机管理，等等。
3. Domain层主要是领域模型的实现，包括领域对象的确立，这些对象的生命周期管理及关系，领域服务的定义，领域事件的发布。
4. Infrastructure层主要是业务平台，编程框架，第三方库的封装，基础算法，等等。

### DDD实践的5层架构
- 与4层架构的区别：1和2之间多一个context层。
 算法及角色-对象映射由Context拥有。
 Context“知道”在当前用例中应该找哪个对象去充当实际的演员，然后负责把对象“cast”成场景中的相应角色

- 在典型的实现
每个用例都有其对应的一个Context对象，而用例涉及到的每个角色在对应的Context里也都有一个标识符。
Context要做的只是将角色标识符与正确的对象绑定到一起。只要触发Context里的“开场”角色，代码就会运行下去。
  
  
### DDD为什么难以落地
1. 需要一个关键的角色，领域专家。他负责问题域，和问题解决域，
 他应该通晓研发的这个产品需要解决哪些问题，专业术语，关联关系
2. DDD需要我们在领域建模花费很多的时间和精力，因为在界限上下文的划分上是非常考验架构师的业务水平。
  如果没有将业务模型很好的识别出来，那么可能很快模型就会在迭代的过程中腐败掉了。
3. 很多应用本身业务逻辑并不复杂，使用DDD的“聚合根”等概念并不划算。
  DDD的优势是能对业务规则提供良好保护，缺点是有一定的规则和复杂度，开发起来没那么快。
4. 领域驱动设计最精华的部分界限上下文，强调了模型和通用语言是针对某个上下文的,
   这样的专用模型易用但不通用，才能发挥作用并容易维护
5. 总结来说，“聚合根、实体、值对象、仓库”属于单个限界上下文的实现范畴，使用的约束比较多；
   “限界上下文”则属于架构设计范畴，是将大型复杂问题分解为若干简单问题的方法，这个肯定会用到。
   
### 概念
- 限界上下文
   1. 一个由显示边界限定的特定职责。领域模型便存在于这个边界之内。
     在边界内，每一个模型概念，包括它的属性和操作，都具有特殊的含义。
   2. 一个给定的业务领域会包含多个限界上下文，想与一个限界上下文沟通，则需要通过显示边界进行通信。
     系统通过确定的限界上下文来进行解耦，而每一个上下文内部紧密组织，职责明确，具有较高的内聚性。
   3. 限界上下文之间的映射关系
     * 合作关系（Partnership）：两个上下文紧密合作的关系，一荣俱荣，一损俱损。
     * 共享内核（Shared Kernel）：两个上下文依赖部分共享的模型。
     * 客户方-供应方开发（Customer-Supplier Development）：上下文之间有组织的上下游依赖。
     * 遵奉者（Conformist）：下游上下文只能盲目依赖上游上下文。
     * 防腐层（Anticorruption Layer）：一个上下文通过一些适配和转换与另一个上下文交互。
     * 开放主机服务（Open Host Service）：定义一种协议来让其他上下文来对本上下文进行访问。
     * 发布语言（Published Language）：通常与OHS一起使用，用于定义开放主机的协议。
     * 大泥球（Big Ball of Mud）：混杂在一起的上下文关系，边界不清晰。
     * 另谋他路（SeparateWay）：两个完全没有任何联系的上下文。
- 开发时的定义
   1. 实体
      当一个对象由其标识（而不是属性）区分时，这种对象称为实体（Entity）。
   2. 值对象
      当一个对象用于对事务进行描述而没有唯一标识时，它被称作值对象（Value Object）。
      它具有不变性、相等性和可替换性。
   3. 聚合根
      一组相关对象的集合，作为一个整体被外界访问，聚合根（Aggregate Root）是这个聚合的根节点
   4. 领域服务
      一些重要的领域行为或操作，可以归类为领域服务。它既不是实体，也不是值对象的范畴。
      当我们采用了微服务架构风格，一切领域逻辑的对外暴露均需要通过领域服务来进行
   5. 领域事件
      领域事件是对领域内发生的活动进行的建模。

### CQRS (Command Query Responsibility Segration 命令处理，查询处理)
写模型： 统一语言，显式的事务边界，复杂的业务逻辑。
读模型：专门为读优化(缓存等)，有不同的SQL如NoSQL分析，简单的类组成。
- [cqrs架构图](../../picture/cqrs.jpg)
   1. Command对象
         Command对象的作用是用来封装命令数据，所以这类对象以属性为主，少量简单方法，但注意这些方法中不能包含业务逻辑。
   2. CommandExecutor
         CommandExecutor的作用是执行一个命令，对于注册的例子，我们会有一个RegisterCommandExecutor的类，它只有一个Execute方法，接受RegisterCommand参数
   3. Command Bus
         作用是将一个Command派发给相应的CommandExecutor去执行

- CQRS架构的优点
    CQ两端架构分离、相互不受束缚，各自独立设计、扩展
    C端通常结合DDD，解决复杂的业务逻辑；Q端轻量级查询，多种不同的查询视图通过订阅事件来更新
    C端通过分布式消息队列水平扩展，天然支持削峰
    EDA架构(event-driven architecture)，整个系统各个部分松耦合，可扩展性好
    架构层面做到无并发，实现Command的高吞吐
    技术架构和业务代码完全分离，程序员不用关心技术问题
    更方便的分工合作
- CQRS架构的缺点
    不是强一致性，而是面向最终一致性
    强依赖高性能可靠的分布式消息队列
    必须有强大可靠的CQRS框架，从头做起成本高、风险大
    必须结合Event Sourcing模式，否则CQ分离意义不大
    Event Sourcing模式的缺点
    一些CQRS的最佳原则提高了开发人员的门槛


ddd 实践：
美团交易系统的ddd： https://mp.weixin.qq.com/s/_VehzjU22Z1AUAPrEoswHQ
美团点评的ddd： https://tech.meituan.com/2017/12/22/ddd-in-practice.html

### 领域驱动设计是一种设计思想
它通过分离技术实现的复杂性，围绕业务概念构建领域模型来控制业务的复杂性，以解决软件难以理解、难以演化等问题。
- 首先体现了分离的思想，它分离了业务复杂性和技术复杂性，
- 其次体现了分治的思想，它通过领域模型、限界上下文或子域进行分治。

### 限界上下文是连接问题空间和解决方案空间的桥梁
- 我们在问题空间分析问题时，它是业务逻辑的边界；
- 限界上下文的识别过程本质上仍然是对问题域拆分和求解的过程，
- 在解决方案空间我们通过限界上下文来确定应用的边界和技术的边界(微服务的边界)

### 领域驱动设计的过程
1. 理解问题域：这个阶段的核心是深入分析业务价值、需求以及构建业务概念模型。产出统一语言和子域划分(主要输出)。
   a. 业务价值分析 (有助于评估系统的复杂性，并且可以指导我们识别最为关键的业务领域)
   b. 业务需求分析  (是一个关键的知识提炼过程, 可以用事件风暴、四色建模以及用例分析等。 美团用的是用例分析方法)
   c. 业务模型分析
       1. 在子域划分上，我们最终识别出了如图所示的这样几个子域，结合我们在价值分析阶段得到的为用户提供一站式服务体验，以及为商家提供一体化售卖平台的这样的核心价值，我们将商品域和订单域作为核心域进行重点建设。
       2. 对于子域的划分方法，可以分别按照业务和组织两个视角来看，从业务视角上可以按照业务环节或业务方向进行划分, 从组织视角上可以按照业务职能部门或团队进行划分。
2. 识别限界上下文：在这一阶段，我们通过组织、业务和应用的边界来确定限界上下文，并且明确不同上下文间的关系和交互。
   a. 组织边界
   b. 业务边界
        1. 我们基于语义相关性和功能相关性对我们在问题域分析阶段所罗列的业务活动进行归类，优先考虑功能相关性，得到初步的限界上下文划分
        2. 那么限界上下文具体要到什么粒度呢，这里跟我们的业务复杂度、技术复杂度以及团队规模有一定的关系，结合我们的实际情况，我们对商品和订单这两个核心域的限界上下文做进一步的识别和划分。
             仔细思考后我们发现，尽管商品和订单是贯穿整个业务流程的核心概念，但在业务流程的不同阶段涉及不同的参与方和关注点，对应到系统能力上的诉求也不尽相同。需要保证系统设计能够更精准地满足各阶段的业务需求。
   c. 应用边界
        1. 我们仍然要遵循先业务后技术的原则，并且在考虑技术因素时，仍然要保证领域模型的完整性和一致性。 我们从质量属性、服务集成和功能复用三个方面对限界上下文做进一步的划分，
        2. 每个限界上下文都封装了特定的业务逻辑和规则，并且可以被视为一个相对独立的软件模块。当需要多个限界上下文协作完成一个完整的业务场景时，它们之间就需要定义清晰的接口和通信机制，这就是所谓的映射关系。

3. 领域建模：包括领域分析、设计建模，以及模型的持续迭代。这个阶段的目标是构建能够反映业务核心概念和规则的模型。
   a. 领域分析建模
   b. 领域设计建模
   c. 持续迭代模型
4. 模型实现：实现阶段主要依赖于应用分层架构、微服务架构和应用集成，确保领域模型能够在系统中得到有效实施。
   a. 分层架构
        1. 服务内部按照分层架构进行实现。整体上基于关注点分离和SOLID原则，分为接入层、应用层、领域层和基础设施层。
        2. 最终需要维护领域层的稳定性，对上由接入层和应用层来隔离变化，对下由基础设施层通过依赖倒置的方式来隔离数据以及外部依赖的差异性和变化。
   b. 微服务架构
   c. 应用集成
        1. 采用基于插件化的集成开发模式。通过扩展点的定义，由各业务线在各自的插件包里基于业务扩展模型进行业务定制化实现，再集成平台领域模型和业务扩展模型，最后实现完整的业务流程和业务场景。


### 根据通信集成模式和团队协作模式，限界上下文之间的映射关系可以分为以下几种主要类型：
1. 共享内核（Shared Kernel）:
     两个限界上下文共享一部分代码或模型。这种方式适用于紧密合作的团队，他们愿意维护共同的代码库。共享内核通常包含基础架构、公共实体或值对象等。
2. 客户方-供应方开发（Customer-Supplier Development）:
    这是一种合同式的合作关系，其中一个团队作为“供应方”负责提供API或其他形式的服务给另一个作为“客户方”的团队。这种模式要求双方就服务的使用达成一致，并且可能需要签订正式的服务水平协议（SLA）。
3. 遵从者（Conformist）:
    一个限界上下文选择遵循另一个限界上下文的模型和接口。这通常发生在下游系统对上游系统的依赖上，下游系统会调整自己的实现以适应上游系统的接口和数据格式。
4. 防腐层（Anticorruption Layer）:
    当两个限界上下文的模型差异很大，或者一方不愿意或不能改变其内部结构来满足另一方的需求时，可以在两者之间建立一个防腐层。这个中间件将不兼容的接口转换为调用方能够理解的形式，从而保护内部模型不受外部变化的影响。
5. 开放主机服务（Open Host Service）:
    一个限界上下文通过公开标准化的服务接口来与其他上下文交互。其他上下文可以通过这些已发布的接口访问资源，而不需要了解内部细节。
6. 发布语言（Published Language）:
    定义一种所有相关方都能理解和使用的通用语言或数据格式，如XML Schema、JSON格式等，用于不同限界上下文之间的信息交换。
7. 合作伙伴（Partnership）:
    两个限界上下文相互依存，彼此之间存在平等的合作关系。它们可能会一起开发接口或共享某些基础设施组件。
每种映射关系都有其适用的场景和挑战，实际选择哪种方式取决于具体的业务需求、技术限制以及团队之间的沟通协作能力。正确地选择和实施映射关系对于确保系统的灵活性、可维护性和团队间的高效合作至关重要。


### 在领域驱动设计（Domain-Driven Design, DDD）中
1. 领域是一个问题空间，代表实际业务问题
2. 领域模型是针对特定领域内的核心业务概念和逻辑进行建模的结果。不仅包含数据结构，还包括这些结构之间的行为和业务规则
   2.1比如订单这个领域模型。 1 包含的实体有：订单，订单项，支付单，发货单等数据库结构  2 行为：添加/更新/支付/查询等。 3. 规则：价格计算规则，库存更新规则，状态转化规则等。
   2.2 一个领域会有多个领域模型
3. 限界上下文。 划定系统的边界
   3.1 一个领域会有一个或多个限界上下文。每个限界上下文专注于解决领域内的某一部分问题
   3.2 一个限界上下文有一个或多个领域模型。限界上下文定义了领域模型的应用范围，它为领域模型提供了一个明确的边界
   3.3 限界上下文之间的交互往往不是单一模式的应用，而是根据具体情况组合使用多种模式。例如，在一个电子商务平台中，订单处理限界上下文可能会通过API调用的方式与支付处理限界上下文进行交互（客户-供应商模式），同时通过消息队列接收来自库存管理限界上下文的通知（事件驱动架构）。此外，为了与旧版系统集成，还可能引入防腐层来隔离新旧系统之间的差异。


在领域驱动设计（Domain-Driven Design, DDD）中，聚合根是聚合的入口点和主要实体。一个聚合是一组相关对象的集合，作为一个整体单元进行处理，主要用于组织和管理复杂的业务实体及其关系，定义一个事务和一致性的边界。
1.以确保业务不变量和规则的一致性
这意味着所有的状态变化都必须通过聚合根来协调，从而确保这些规则得到遵守。例如，在订单处理系统中，订单作为聚合根可以确保只有在支付完成后才能更新发货信息
2. 聚合根负责管理对聚合内部对象的所有访问，并且外部对象只能通过与聚合根交互来影响聚合内部的状态。
   举例说明：在电子商务系统中，订单可以是一个典型的聚合根。它包括了订单项（OrderItem）、支付信息（PaymentInformation）、发货详情（ShippingDetails）等子实体和值对象。所有对这些子实体或值对象的操作都必须通过订单本身来进行。例如，添加或删除订单项、更新支付状态或修改发货地址，都需要直接操作订单实体，而不是单独操作其子实体。
3. 保证事务一致性
   在一个聚合内，所有的操作都应该被当作一个整体来看待。这意味着如果一项操作失败，则整个操作应视为未完成，以保持数据的一致性。聚合根是实现这种一致性的关键点，因为它负责协调聚合内所有实体的操作。

比如订单微服务，优惠券微服务，支付微服务，履约微服务， 有4个微服务，可以有4个子聚合根，每个微服务一个，  而不是像上面那样强制一个订单的聚合根。

评估聚合根的设计是否足够有效，主要可以从以下几个方面进行考量：
1. 业务一致性
   聚合根应该能够确保聚合内部的数据一致性和完整性。这意味着所有对聚合内数据的修改都应该通过聚合根来进行，从而保证任何操作都不会违反聚合内的业务规则或不变量
2. 事务边界
   每个聚合应该代表一个最小的事务边界。这意味着在一次事务中，只应修改单个聚合的状态。如果发现需要跨多个聚合进行事务处理，这可能表明聚合设计不够合理，或者存在不必要的复杂性。
3. 性能和扩展性
   合理的聚合设计有助于提高系统的性能和可扩展性。过大的聚合可能导致锁争用和并发问题，影响系统性能；而过小的聚合则可能导致过多的分布式事务管理，增加系统复杂度。因此，找到合适的聚合大小对于维持良好的性能至关重要。
4. 聚合之间的依赖关系
   理想情况下，聚合之间应该是低耦合的，尽量减少直接依赖。聚合间的通信应该通过明确的接口（如领域服务、事件等）进行，而不是直接引用其他聚合的实体。这样可以降低系统各部分之间的耦合度，提高模块化水平。