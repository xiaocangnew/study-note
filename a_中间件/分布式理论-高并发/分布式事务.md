### 两阶段提交
- 操作流程(一个协调者，n个参与者)
  1. 协调者将事务信息发给参与者，参与者告知协调者自己的决策
  2. 协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作，然后将结果发给参与者进行执行。
- 缺点：
1.同步阻塞问题。
   执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
2.单点故障。
   由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。
   如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题
3.数据不一致。
   在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后(因为各种原因)导致只有一部分参与者接受到了commit请求。
   这部分参与者接到commit请求之后就会执行commit操作。
   但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。
4.二阶段无法解决的问题：
   协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。
   那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。

### 补偿事务(TCC) 
- 核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：
    - 1. Try 阶段主要是对业务系统做检测及资源预留
    - 2. Confirm 阶段主要是对业务系统做确认提交。
         默认Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。
    - 3. Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。
- 举个例子: 假入 Bob 要向 Smith 转账，思路大概是： 我们有一个本地方法，里面依次调用
    - 1. 首先在Try阶段，要先调用远程接口把Smith和Bob的钱给冻结起来。
    - 2. 在Confirm阶段，执行远程调用的转账的操作,转账成功进行解冻。
    - 3. 如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。

- 优点： 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些
- 缺点： TCC属于应用层的一种补偿方式，所以需要实现 很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。
- TCC分布式事务框架，比如国内开源的ByteTCC、himly、tcc-transaction

### 最大努力通知型
- 特点：业务活动的主动方在完成业务处理之后，向业务活动的被动方发送通知消息。
    主动方可以设置时间阶梯通知规则，在通知失败后按规则重复通知，知道通知N次后不再通知。
    主动方提供校对查询接口给被动方按需校对查询，用户恢复丢失的业务消息。
- 适用范围：银行通知，商户通知。
- 成本：业务查询与校对系统的建设成本

### 基于可靠消息的最终一致性(异步确保型)
- 本地消息表方案(本地消息服务)
    - 本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。
       - 1. 在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。
       - 2. 之后将本地消息表中的消息转发到 Kafka 等消息队列中(定时任务)，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。
       - 3. 在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。
    - 优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。
    - 缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。

- RocketMq 事务消息方案(独立消息服务)
    - RocketMQ4.3之后实现了完成的事务消息，实际上是将本地消息表封装至了MQ内部，解决Producer端消息发送与本地事务执行的原子性问题
    - RocketMQ事务消息设计则主要是为了解决生产者端消息发送与本地事务的原子性问题，RocketMQ的设计中，broker与producer端的双向通信能力，
       使得broker天生可以作为一个事务协调者。其存储机制为事务消息提供持久化的能力，其高可用机制以及可靠消息设计原则为其在异常发生时能报保证达成事务的最终一致性。
    - 执行流程如下（rocketMq事务是基于事务反查的机制来解决事务消息提交失败的问题）：
      1. Producer发送消息：Producer发送事务消息给MQ，MQ将消息标记为Prepared（预备状态），注意此时该消息是无法被订阅方消费的。
      2. MQ回应给Producer消息发送方已收到消息。
      3. Producer消息发送方执行本地事务。
      4. 消息投递：Producer消息发送方本地事务执行完成后，自动向MQ发送commit消息，MQ则将1中消息的状态修改为“可消费”状态，此时MQ的订阅方可以消费该消息。若本地事务执行失败，MQ接受到rollback消息，则MQ将该消息删除。
      5. 事务反查：如果Producer消息发送方执行本地事务前挂掉或者超时，MQ会通过事务回查功能询问Producer执行本地事务的状态。
          为了支撑这个事务反查机制，我们的业务代码需要实现一个反查本地事务状态的接口，告知 RocketMQ 本地事务是成功还是失败


### didi 
1. 解决问题：
服务化之后，多个系统之间数据的一致性问题。
1.1 比如下单环节，需要同时锁券和保存订单等，业务需要保证这两步操作的一致性。如果出现异常场景，例如锁券成功，保存订单失败，需要将券进行解锁。同时由于分布式场景下面，解锁也可能会失败，需要有一种机制保证最终一致性。
1.2 支付成功，需要同时扣减库存，修改订单状态，给台账系统发送消息触发分佣，触发采购系统进行采购等，这几个环节的一致性需要保障，否则如果订单修改为支付成功状态，但是未能触发团长分佣，会引起客诉。
在微服务架构下，上述场景非常普遍，所以需要统一的解决方案。

2. 初步方案：
使用DDMQ的事务消息的解决方案，http://way.xiaojukeji.com/article/8608

3. 会议内容：
分布式事务常见解决方案的优劣对比
DDMQ事务消息的优势
使用方式：
同步操作，例如上述解决问题的1.1，基准操作保存订单放在最后一步，前面都是准备动作，基准操作失败，利用提前发送的事务消息进行准备动作的回滚
异步操作，例如上述解决问题的1.2，使用消息重试进行尽可能的成功尝试，对于重试不能成功的消息，需要触发逆向流程，例如因为超卖之后导致支付回调不能成功的话触发逆向流程。
demo代码演示
注意事项：
保证发送消息成功，发送前置
幂等，原因消息是可能重复的
回查时间不能太短，时序问题造成的空回滚，例如上述解决问题的1.1，如果消息过来太快，此时订单还没有来得及保存，消费者可能会认为订单保存失败，对券进行解锁，后面订单却保存成功，造成不一致



