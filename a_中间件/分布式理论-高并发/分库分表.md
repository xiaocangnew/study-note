### 分库分表目的
1. 为了分摊写负载；而不是分摊读负载；
2. 读负载过高时，可以使用redis，读写分离等。

### 出现问题时需要进行分库分表
1. cpu问题(慢sql， 表数据量超过千万查询变慢)
2. io问题 (磁盘io瓶颈，热点数据太多，每次查询产生大量io； 网络io瓶颈，请求数据太多，带宽不够)
3. 连接数(连接数不够用了)

###  垂直拆分(一个表拆分为几个表 / 不同的表放到不同的库中)
- 场景分析
1. 垂直分库
系统绝对并发量上来了，并且可以抽象出单独的业务模块。(服务化)
2. 垂直分表
表的记录并不多但字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。
以至于数据库缓存的数据行减少，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈。

- 优点：
1. 跟随业务进行分割，和最近流行的微服务概念相似，方便解耦之后的管理及扩展。
2. 高并发的场景下，垂直拆分使用多台服务器的CPU、I/O、内存能提升性能，
 同时对单机数据库连接数、一些资源限制也得到了提升。
3. 能实现冷热数据的分离。

- 缺点：
1. 部分业务表无法join，应用层需要很大的改造，只能通过聚合的方式来实现。增加了开发的难度。
2. 当单库中的表数据量增大的时候依然没有得到有效的解决。
3. 分布式事务也是一个难题。

### 水平拆分( 将一个表按id放到不同的表 / 将数据按id放到不同的库中)
- 场景分析
1. 水平分库
系统绝对并发量上来了(order表并发)，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。
(库多了，io和cpu的压力自然可以成倍缓解)
2. 水平分表
单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈。

- 优点有：
1. 水平扩展能无线扩展。不存在某个库某个表过大的情况。
2. 能够较好的应对高并发，同时可以将热点数据打散。
3. 应用侧的改动较小，不需要根据业务来拆分。

- 缺点有：
1. 路由问题。需要增加一层路由的计算，如果不带分片键查询会产生广播SQL。
2. 跨库join的性能比较差。
3. 需要处理分布式事务的一致性问题。

### 水平分库分表需要处理的问题
- 1. 非partition key跨库跨表分页查询问题， 多维度查询问题， group by问题
      1. 全表冗余(使用双写方式，主订单写完后，发送mq， 运营系统根据其他分区键重新插入mysql，冗余数据)
      2. 建立一张汇总表 (使用es，监听mysql的binlog，重建索引，支持多维度查询)

- 2. 扩容问题
4.1 水平扩容库时，使用升级从库法(用的较少)
从库因为是主库的备份，有所有数据。 hash由2变为4时，直接将从库升级为主库，同时删除所有库中多余数据。
4.2 水平扩容表时，使用双写迁移法(同步或异步)
步骤：1. 应用配置双写，部署(旧库为tb_0,tb_1； 扩容后，新库tb_0,tb_1,tb_2。主要是为了保证增量数据在新旧库库都有)
 2. 将旧库中的数据按照新的hash规则写入新库中
 3. 校验数据的正确性
 4. 去掉双写，删除旧库

- 5. 跨库事务问题
使用分布式事务(使用2pc，tcc，本地消息表等)

### [非partition key跨库跨表分页查询问题](https://mp.weixin.qq.com/s/h99sXP4mvVFsJw6Oh3aU5A?)
方法一：全局视野法
（1）将order by time offset X limit Y，改写成order by time offset 0 limit X+Y
（2）服务层对得到的N*(X+Y)条数据进行内存排序，内存排序后再取偏移量X后的Y条记录
这种方法随着翻页的进行，性能越来越低。

方法二：二次查询法
（1）将order by time offset X limit Y，改写成order by time offset X/N limit Y
（2）找到最小值time_min
（3）between二次查询，order by time between $time_min and $time_i_max
（4）设置虚拟time_min，找到time_min在各个分库的offset，从而得到time_min在全局的offset
（5）得到了time_min在全局的offset，自然得到了全局的offset X limit Y

方法二：业务折衷法
  1. 禁止跳页查询：
       用正常的方法取得第一页数据，并得到第一页记录的time_max，每次翻页，将order by time offset X limit Y，
       改写成order by time where time>$time_max limit Y,以保证每次只返回一页数据，性能为常量。
  2. 允许模糊数据
       将order by time offset X limit Y，改写成order by time offset X/N limit Y/N

方法三： [离线计算+有损服务](https://www.cnblogs.com/lhh-north/p/11140940.html)
其实分表环境下就不适宜再做分页查询的功能.但是业务上的需求并不是说砍就砍的, 很多情况下分页功能是必须的。
分页查询的存在通常也是为了保护数据库, 去掉了分页功能, 数据库的压力反而更大.
但是分页功能不在分表环境里面做, 而是在另外一张汇总表里面做分页查询的功能.
大概的方案就是:
1. 正常的业务读写分表
2. 根据具体的业务需求,例如实时计算/离线计算技术(spark, hadoop,hive, kafka等)生成各分表的一张汇总表
3. 分页查询的接口直接查询汇总表
另外还要注意这个方案对业务来说肯定是有损的, 具体表现为:
1. 不管是离线计算还是实时计算, 都不能保证实时性, 查询结果肯定是有时延的
2. 由于汇总表是不可能包含分表的所有数据的, 所以汇总表肯定是只包含部分数据的,例如只有一个月内的,具体根据业务场景而定


### 几种典型的数据分片规则为
1. 根据数值范围
- 优点：
1. 单表大小可控
2. 天然便于水平扩展，无需对其他分片的数据进行迁移
3. 使用分片字段进行范围查找时，连续分片可快速定位分片进行快速查询，有效避免跨分片查询的问题。
- 缺点：
1. 热点数据成为性能瓶颈。连续分片可能存在数据热点。
 例如按时间字段分片，有些分片存储最近时间段内的数据，可能会被频繁的读写，而有些分片存储的历史数据，则很少被查询
2. 根据数值取模
- 优点：
数据分片相对比较均匀，不容易出现热点和并发访问的瓶颈
- 缺点：
1. 后期分片集群扩容时，需要迁移旧的数据(一致性hash也需要迁移数据)
2. 容易面临跨分片查询的复杂问题。如果频繁用到的查询条件中不带分片键时，将会导致无法定位数据库，
  从而需要同时向4个库发起查询，再在内存中合并数据，取最小集返回给应用，分库反而成为拖累。
3. [1和2相结合](https://www.cnblogs.com/liuqingzheng/p/10755148.html)

### 一些思考：
1. 并非所有表都需要水平拆分，要看增长的类型和速度。水平拆分是大招，拆分后会增加开发的复杂度，不到万不得已不使用
2. 在大规模并发的业务上，尽量做到在线查询和离线查询隔离，交易查询和运营/客服查询隔离
3. 拆分的维度的选择很重要，要尽可能在解决拆分前的问题的基础上，便于开发。
4. 数据库没你想象的那么坚强，需要保护，尽量使用简单的、良好索引的查询，这样数据库整体可控，也易于长期容量规划以及水平扩展


### 分布式数据库中间件
- 1. proxy模式 (mycat, DBProxy等)
select和update语句都是发送给代理，由这个代理来操作具体的底层数据库。必须要求代理本身需要保证高可用
- 1.1. 优缺点
优点： 集中式管理监控， 方便升级， 解决连接数问题
缺点： 有中间层的成本开销， 必须保证高可用
- 2. 客户端式架构(TDDL、 Sharding-JDBC等)
通常在连接池上做了一层封装，内部与不同的库连接，sql交给smart-client进行处理
- 2.1 优缺点
优点：无中间层的成本开销(直连数据库性能更好，省钱)
缺点：必须自己管理连接数，维护监控麻烦
- 3. 收费的公有云(UCloud的UDDB, 阿里DRDS，都是proxy模式)
- 运维达到工业标准
   0. 部署简单
   1. 去掉中间件单点
   2. 设置系统监控和警报，及时发现故障
   3. 采集中间件的日志，做关键指标的可视化。
   4. 数据迁移自动化


### 数据库秒级平滑扩容架构方案
hashmap rehash过程类似
数据库hash分表后的扩容方案
需要扩容，那么肯定是要有迁移工具的支持，全量+增量
