### 分布式锁类型
1. redis分布式锁
2. zookeeper分布式锁

### 分布式锁要素
1. 不会发生死锁，宕机可以自动释放锁
2. 加锁和解锁必须是同一个客户端；
3. 性能考虑；
4. 锁的基本要素；

### redis锁 VS zookeeper锁
- redis的分布式锁，
   - 缺点：
      1. redis的设计定位决定了它的数据并不是强一致性的，cluster/master-slave架构主从异步复制问题：
         在redis master实例宕机的时候，可能导致多个客户端同时完成加锁。
         即便使用redlock算法来实现,也无法保证其实现100%没有问题.
   - 优点
     1. 使用redis实现分布式锁在很多企业中非常常见，而且大部分情况下都不会遇到所谓的“极端复杂场景”
     2. 最重要的一点是redis的性能很高，可以支撑高并发的获取、释放锁操作。

- zk分布式锁
   - 优点
     1. zookeeper天生设计定位就是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。
     2. 如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。
   - 缺点：
     1. 如果有较多的客户端频繁的申请加锁、释放锁，对于zk集群的压力会比较大。
     2. 需要设置好会话超时时间，否则可能失去链接导致释放锁，出现问题。 更新sql时要加版本号。
     
- 关键区别
    1. zk有个比较高的一致性，强调的cp， redis 强调的是ap。
    2. 性能方面，redis性能更好；


###  redis 分布式锁的问题和解决
1. redis单机分布式锁，在主从模式下存在锁丢失， 即在master上加锁了， 还没同步到slave上就down了，此时别人也能加锁；
2. 使用集群模式下的redLock解决上述问题；
     1. 2n+1个redis实例， 使用同样key值，在超过一半的实例中分别请求上锁并成功;
     2. TTL时长 要大于正常业务执行的时间+获取所有redis服务消耗时间+时钟漂移
3. 虽然说RedLock算法可以解决单点Redis分布式锁的安全性问题，但如果集群中有节点发生崩溃重启，还是会锁的安全性有影响的。
   具体出现问题的场景如下：假设一共有5个Redis节点：A, B, C, D, E。设想发生了如下的事件序列：
       1. 客户端1成功锁住了A, B, C，获取锁成功（但D和E没有锁住）
       2. 节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了
       3. 节点C重启后，客户端2锁住了C, D, E，获取锁成功
   这样，客户端1和客户端2同时获得了锁（针对同一资源）。
   解决方式也很简单，也就是让Redis崩溃后延迟重启，并且这个延迟时间大于锁的过期时间就好。这样等节点重启后，所有节点上的锁都已经失效了。也不存在以上出现2个客户端获取同一个资源的情况了。　

### 分布式锁的通病(redis，zookeeper)：
1.  对锁的超时时间使用不合理，上锁之后，进入排他线程执行代码，还没执行结束(gc卡顿，有些操作很耗时)就已经到超时时间把锁释放了；

