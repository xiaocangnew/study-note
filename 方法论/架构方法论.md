### 重构问题描述：
1. 维护成本高，开发迭代效率低(服务语言框架不统一、框架老旧;数据链路不统一，同一种功能多种实现; 测试环境搭建困难，联调效率低; 配置分散)
2. 数据不一致问题
   (取值逻辑不一致, 下游依赖数据获取链路不一致)
3. 稳定性低
   (服务框架老旧，本身没有 tp99 和 slo 监控; 服务可观测性差，定位问题困难;
   框架老旧，性能差，稳定性保障机制不完善)
   4.工程质量差
   (单测覆盖率低于10%，无接口测试; 代码规范问题 x 个，研发指标得分73.69)

### 当在进行 DDD 领域拆分时，遇到某个业务逻辑或功能“既可以放到 A 服务，也可以放到 B 服务”的情况，怎么解决：
>>> 说明你在做界限上下文（Bounded Context）划分时遇到了模糊地带。这是很常见的问题，尤其是在多领域交叉、业务规则共享或职责边界不清晰的情况下。

核心判断原则
   1.1 看谁拥有该业务规则的最终决策权
   1.2 看哪个上下文会频繁变更或演化此规则。把变化频率高的逻辑放在它的所属服务中，便于维护和演进
   1.3 模拟场景测试归属。通过场景推导出自然归属。 A 不可用，B 是否还能完成业务？
   1.4 问业务专家：DDD 强调统一语言和业务驱动分析，最好与领域专家一起讨论。

### 领域要封闭
 比如 推荐视频课的ai作业， 作业不应该关注视频课的东西， 推荐系统和视频课系统是数据互通的， 作业在中间只起桥梁作业，不关心json的具体格式

### 方案设计时，按照正确的思路去设计，不要按照现有实现的方式去设计
（ai诊断时，s2不支持查看批改详情页。 学习规划，拍批诊断的薄弱点加练需要接入作业功能，这时作业流转方式， 使用原来正确的流程，而不是再写一个分支流程）

### 功能和工具
拍照诊断是一个功能(上下游自洽)， 还是一个工具(单纯提供一个tool)


### 领域建模的认知增加：
0. 核心领域是建模中最关键的一步。 (反映了业务中核心关注点，聚焦业务价值，指导架构决策，围绕它来设计软件架构。 优化资源配置，将研发中心放到核心上。对非核心功能采用更加经济高效的实现方式。不仅帮助团队集中精力解决最关键的业务问题，还为后续的设计和开发工作提供了清晰的方向)
   有时团队可能会陷入实现细节中，而忽视了对核心领域逻辑的理解和建模。
   如何识别核心领域？ 基于用户使用场景频率， 用户需求与业务目标之间的交集。 比如x1学习机。业务目标是释放家长，让孩子自主学习。
   当前用户学习与练习场景占到总使用的80%. 所以是核心领域。用户的薄弱点与知识图谱分析， ai类使用， 目的都是为了让孩子更精准的定位自己的问题/解决学习问题， 虽然他们很重要，但更偏向工具类。

1. 作业在发布时就会生成练习记录。
   认知误区： 认为作业就是一次练习， 一次练习有练习记录，所以作业也会有练习记录， 在布置时就会生成记录。(但作业和练习记录是两个领域)
   领域知识：
   作业是一个单独的领域(核心关注点： 布置作业流程的各个环节痛点(选择内容，发布作业，进度监控，作业批改，作业反馈)，作业状态机，各种触达， 用户作业功能使用率， 作业布置后完成率，作业最佳布置长度分析等)，
   练习记录是一个单独的领域(核心关注点：练习内容，练习方式，练习结果)
   作业与练习领域分离后的好处：
   区分后可以独立演化，降低领域开发理解成本。比如字词听写新增机上练习模式后，不需要作业也增加新练习模式，练习模式本质上是练习记录的参数。
   隔离失败风险，作业的发布不需要依赖练习记录服务的存活，提升核心服务的可用性。

2. ai对话领域拆分。
   认知模糊区域： ai对话包含场景-对话-轮次。  
   练习结果进行ai诊断的产品需求是否能套用ai对话的能力。产品需求里ai诊断是一次性行为，中间调用ai还可能失败，需要进行重试。
   a. 如果能套用，则需要融合进ai对话的能力模型里。 需要对ai对话的轮次进行 1:n的关系套用(比如调用ai诊断接口成功，但是进行ai对话时失败了，重试对话)。
   那么就需要在ai对话能力模型里新增一层聚合层。
   b. 如果不套用ai对话模型， 那么仅仅是把ai当成一个rpc，获取ai的结果，而不是一次对话。
   基于a和b方案，更倾向于b方案， 那么就对原有的ai对话模型进行领域扩充， 对话是ai的一个领域， rpc工具调用也会是ai的一个领域。 ai有两个子领域。

3. 实体关系：
   实体关系是领域模型的具体体现 (实体关系不仅包括数据库表， 还包括redis 数据结构， config的结构，enum枚举等)
   在数据库这个case中，就必须按照领域的方式来严格实现， 每次新增表都要思考是否在领域范围内， 表上新增字段也是一样

4. 领域模型：
   要跳出现有代码的逻辑， 在业务上思考， 什么是通用流程， 正确的模型是什么。 然后再看代码， 看看gap 在哪里，怎么补齐。


先面向数据库设计， 成熟的标志： 结构化思考， 数据库表关系， 状态流转，流程图等很熟悉。
然后再考虑ddd。 ddd第一步考虑的是领域实体， 实体流转。剩下的再问华哥






模型抽象
将现有的所有场景进行抽象， 往上走一层，或者思考通用方式，抽象出统一的能力， 进行领域封装。 (比如ai每日练，计算专练，字词听写，视频课学习 这几个场景都是 学练场景，可以进行统一抽象，抽出学练领域。 虽然前三个都是练习场景， 但是要融入视频课，进行抽象时，就要考虑共性和特性， 是进行全场景覆盖抽取模型，还是另起炉灶建立俩模型。 比如这里就是抽取了统一学练模型。 但是在学情诊断调用ai的rpc接口时，就是把ai分为对话模型和能力模型)

比如对元器件的封装， 虽然有不同的功能，但都是一种元件，封装到一起



领域的存粹性：
relation关系不应该存在exerciseRecord服务中。 是特性的，特性的应该放在homework中。如果是共性的，可以放在exereciseRecord中


如果领域拆分时，某个业务感觉技能放到A服务，也能放到B服务， 这时该怎么处理：

做数据库表设计时，需要考虑到数据分析要怎么用这些数据


### 业务怎么拆分的，为什么要这么拆分，依据是什么，依据的原则是什么，效果怎么样，怎么评估？ 组织架构上聊，
1. 回答“依据是什么”的时候，关键是要结合DDD领域拆分的理论基础和实际需求进行阐述。以下是一些主要原因：
1.1 复杂业务逻辑的处理
   - 项目涉及高度复杂的业务逻辑，使用DDD可以将核心业务规则集中在一个或多个领域对象中，简化问题域和技术域的交互。
   - 通过领域拆分，可以更清晰地定义和管理业务流程，避免代码混乱。
1.2 降低技术债务
   - DDD通过将技术细节与业务逻辑隔离，可以减少过度耦合的问题，降低系统的技术债务。使得代码更易于理解和维护
1.3 提高测试效率
   - 通过定义明确的领域模型，可以为单元测试和集成测试提供清晰的边界条件，从而提高测试效率。
1.4 促进团队协作
   - DDD通过明确的领域概念和规则，帮助开发、测试、设计等不同角色更好地理解业务需求，从而促进团队协作。
1.5 支持快速迭代
   - 通过将问题域和技术域分离，可以在前端和后端进行独立开发，并通过事件发布机制实现数据同步，支持快速迭代。

2. 怎么进行效果评估？ 为了回答“怎么进行效果评估”，需要从技术和业务两个维度来分析效果。以下是一些具体方法：
2.1 技术层面
- **代码复杂度：** 比较项目在DDD实施前后的代码复杂度，观察是否减少了技术债务。
- **可读性和可维护性：** 检查领域对象、模型和接口等的设计是否清晰，便于理解和修改。
- **测试效率：** 评估单元测试和集成测试的覆盖率，是否由于DDD实施而提高了代码的测试性。
- **性能优化：** 比较系统在处理复杂业务逻辑时的性能表现，看看是否通过领域拆分实现了性能提升。
2.1 业务层面
- **业务规则执行：** 确保DDD设计后的系统能够正确执行核心业务规则，并满足项目需求。
- **用户体验：** 新增埋点，评估进入率，完成率等各种指标，评估系统在实际使用中的流畅性和易用性。
- **系统扩展性：** 检查系统是否能够轻松扩展功能或处理新的业务场景。
2.3 具体指标
- **代码行数减少：** 比较DDD实施前后代码的行数，看是否实现了简化。
- **测试覆盖率：** 通过测试工具（如Jenkins、Selenium等）监控和评估测试效率。
- **性能提升：** 使用 profiler 工具分析系统性能，查看处理复杂逻辑时的耗时变化。


### 在一个有8年经验的java研发人员，在简历中这样写了一段：
>>> 对课程及 app 方向根据 DDD 领域驱动模型做了微服务化改造，将原有的大单体服务拆分为9个自治上下文，新业务需求接入时间平均缩短了3人日，需求变更影响范围缩短了百分之三十，
> 通过子域的自治提升了服务稳定性，减少了百分之四十的课程类客诉; 这段描述有问题吗，从领域建模专家的视角来看

1. 具体性：虽然提到了一些具体的数字，如“缩短了3人日”，“减少了百分之三十的需求变更影响范围”，以及“减少了百分之四十的课程类客诉”，但没有提供这些数据是如何得出的背景信息。增加一些关于如何度量这些改进的具体方法或基准线的信息会更有说服力。
    1.1 对于这些改变，需要从数据上说明(首先要有数据收集渠道，比如监控和日志，报障率，用户或组内反馈等，建立基准线，涵盖不同规模和复杂度的工作.优化前后的数据对比进行，持续改进)
        1.1.1 减少了百分之三十的需求变更影响范围 (通过代码版本控制系统（如Git）的日志来实现，查看每次提交影响的具体文件列表)
            在重构之前，当你需要添加一个新的功能，这个变更可能会影响到用户管理、订单处理、支付网关集成等多个模块，总计涉及修改70个文件。
            实施DDD和微服务化改造后：现在，因为系统被合理地划分为多个子域（如用户管理子域、订单处理子域、支付子域等），同样的需求变更只需修改与支付相关的服务中的20个文件，其他子域的服务不受影响。
        1.1.2 度量“减少了百分之四十的课程类客诉”这样的改进 (明确定义哪些类型的反馈或问题被视为“课程类客诉”)
            改造前的数据收集：在一个特定的季度内（比如2024年第三季度），通过客服系统和用户反馈表单共收到了200条关于课程相关的客诉，包括课程视频加载失败、课程内容有误、考试系统故障等。
            实施DDD和微服务化改造：经过数月的努力，完成了系统的重构工作，旨在提升系统的稳定性和响应速度，特别是针对课程内容管理和分发的部分。
            改造后的数据收集与分析：接下来的一个季度（即2025年第一季度），再次统计了来自相同渠道的课程相关客诉。这次只收到了120条客诉，相比之前减少了80条，即减少了40%
        1.1.3 度量“缩短了3人日”的改进
            改造前的数据收集：在一个具体案例中，添加一个新的课程模块到平台上需要跨多个部门协作，包括前端开发、后端开发、测试等。根据记录，整个过程花费了大约5人日（即5个开发者各一天，或者是单个开发者5天）。
            实施DDD和微服务化改造：经过一段时间的努力，完成了系统的重构工作，目的是让各个子域更加独立，减少不同部分之间的依赖性，从而加快开发和部署速度。
            改造后的数据收集与分析：接下来，在新的架构下，当团队需要添加类似的课程模块时，由于服务间的解耦合和更清晰的职责划分，使得前端和后端可以并行开发，减少了等待时间和协调成本。最终，这个新模块仅用了2人日就完成了上线准备。

2.关联性和因果关系：说明一下这些改进与采用DDD和微服务架构之间的直接联系是什么。
2.1 为什么选择DDD而不是其他方法？
        复杂业务领域的处理：对于具有复杂业务逻辑的应用程序，DDD提供了一种有效的策略来管理和组织代码，使其更加符合业务的实际运作方式。
        高耦合低内聚问题的解决：在传统的单体应用中，随着功能的增长，可能会出现高耦合低内聚的问题。DDD通过明确的界限上下文和聚合根等概念，帮助解决了这些问题 ，提高了模块间的独立性。
        促进团队沟通和协作：DDD提倡开发团队与领域专家紧密合作，共同建立对业务领域的深刻理解。这种方法不仅促进了更好的软件设计，也有助于团队成员之间以及团队           与利益相关者之间的沟通，让产品运营等都了解技术的领域模型，方便后期工作。
        适应变化的能力：现代软件开发需要快速适应市场变化，DDD的设计理念和微服务架构的灵活性，使得系统能够更快地响应业务需求的变化，保持竞争力。
2.2 使用ddd之后的优点有哪些
         清晰的界限上下文：
            DDD通过定义清晰的界限上下文来划分业务领域，这有助于将复杂的业务逻辑拆解为更小、更易于管理的部分。这种拆分不仅使系统的结构更加清晰，而且也使得变更的影响范围可以被有效限制在一个或少数几个相关的子域内，提高开发效率。
         增强系统的稳定性和可靠性：
            由于每个微服务相对独立，单个服务中的故障不会轻易影响到整个系统。DDD强调围绕业务能力组织代码，确保了每个服务都有明确的责任和边界，这有助于减少错误并提高服务的稳定性。
         支持灵活的技术选型和优化：
            微服务架构允许针对不同的服务选择最适合的技术栈，而不需要在整个应用中统一使用相同的技术解决方案。这样可以根据具体的需求和技术挑战灵活调整，以达到最佳性能和维护性。
         提升代码质量和可维护性：
            DDD鼓励根据实际业务逻辑组织代码，使代码结构更加合理且易于理解。结合微服务架构，可以使各个服务的职责单一且明确，便于维护和扩展，同时也降低了技术债务的风险(服务owner，将重构作为考核点)。
 2.3 在大单体项目重构时，如果不用ddd，还有其他方式吗(ddd 是一种软件设计方法，还有其他设计方法吗)
   2.3.0. 单体架构优化
      描述：即使不转向微服务，也可以通过对现有的单体应用进行模块化、分层等优化来提升其性能和可维护性。
      适用场景：对于规模较小的应用或者那些不需要频繁变更和扩展的应用来说，优化单体架构可能是一个更简单且成本效益更高的选择。
      常用方式：
         1. 分层优化(3层，表示层-逻辑层-数据层， 4层， 表示层-接口层-逻辑层-数据层，)
         2. 模块化，(利用面向对象， 或者领域划分方式进行)
         3. 数据访问优化，加缓存， 4. 异步处理，队列消息等。5. 代码质量与单元测试等。
   2.3.1 微服务架构
        适用场景: 当应用需要高度扩展性和灵活性时使用，特别是对于云原生应用来说非常合适。
        优点: 每个服务都可以独立地进行开发、部署和扩展；提高了故障隔离能力。
        缺点: 增加了分布式系统的复杂性，如服务发现、负载均衡等问题。
        与soa架构的联系：
           1. 两者都旨在通过分解大型应用程序为较小的部分来提高可维护性、可扩展性和复用性。
           2. 都强调服务之间的松耦合，以及如何定义清晰的服务接口以便于交互。
        与soa的区别：
           1. 规模和粒度：SOA：倾向于较大的、更粗粒度的服务，这些服务可能包含多个业务功能。它们通常用于企业级应用集成。微服务：强调细粒度的服务划分，每个服务专注于单一的业务能力。这种设计更适合于快速迭代和部署。
           2. 通信机制：SOA：常用的企业服务总线（ESB）作为中介来处理服务间的通信，这可能会引入额外的复杂性和瓶颈。微服务：倾向于使用轻量级的协议如HTTP/REST或消息队列进行直接通信，减少中间件依赖。
           3. 技术栈灵活性：SOA：由于其集中式管理特性，往往要求所有服务遵循相同的技术标准和协议。微服务：允许每个服务选择最适合自身需求的技术栈，提供了更大的灵活性。
   2.3.2. 面向服务的架构（SOA）
      描述：SOA是一种将应用程序的不同功能单元（称为服务）通过定义良好的接口和协议联系起来的设计方法。这些服务是独立的，并且可以通过网络进行通信。
      适用场景：适合于需要集成多个现有系统的大型企业环境，尤其是那些希望重用已有组件或服务的企业。
      优点: 提高了系统的模块化程度，使得不同的团队可以独立开发和部署服务；促进了重用性。
      缺点: 可能导致复杂的服务间通信问题；初期设置成本较高。
      核心思想: SOA的核心在于通过网络将不同的功能模块（服务）连接起来，这些服务使用通用协议进行通信，目的是为了实现服务的重用和整合，使得企业内部          或不同企业间的各种应用能够更高效地协同工作。而DDD侧重于理解复杂的业务领域，并通过模型来表达领域知识，旨在通过构建一个与业务领域紧密结合的软件系统来解决复杂业务问题。)
      关注点: SOA更加注重于如何定义服务接口以及如何使这些服务之间进行有效的交互。它强调的是服务的可发现性、互操作性和松耦合特性。 (DDD聚焦于业务逻辑的建模，强调领域模型的重要性，提倡根据业务领域的边界来划分模块（即限界上下文），从而确保每个模块都能精确反映业务领域的某一部分。)
      实战例子:
        银行系统中，不同银行服务如贷款、存款、信用卡等可以作为独立的服务来开发和维护。
        电商平台中，库存管理、订单处理、用户管理和支付处理等功能可以被设计为独立的服务。
      实际上，在实际项目中这两种方法常常结合使用：利用DDD来细化和优化各个服务内部的结构和逻辑，同时通过SOA的方法论来确保这些服务可以有效地协作。这种组合可以帮助团队既构建出具有高度一致性和内聚性的单个服务，又能保证整个系统的灵活性和扩展能力。
   2.3.3. 事件驱动架构（EDA）
      描述：EDA是一种设计分布式异步架构的技术，它通过事件生产和消费来促进应用程序组件之间的松散耦合和交互。是一种通过生产、检测、消费和响应事件来       构建系统的设计方式
      适用场景：非常适合需要处理大量并发请求、对实时数据流处理有要求的应用，或者需要响应外部事件的应用。
      优点: 提高了系统的可扩展性和可伸缩性；非常适合异步处理。
      缺点: 设计和调试较为复杂；可能难以追踪事件流程。
      实战例子:
            在线广告系统根据用户的点击行为实时调整广告投放策略。
            社交媒体平台通过监听用户活动事件（如点赞、评论）来更新动态信息流。
   2.3.4. 六边形架构（Hexagonal Architecture）
      描述：也被称为端口和适配器架构，它旨在使业务逻辑与外部因素（如数据库、用户界面等）分离，使得核心逻辑不受外部变化的影响。
      适用场景：适用于希望保持业务逻辑干净、易于测试并且能够轻松替换外部依赖的项目。
   2.3.5. 函数式编程和架构(FP)
      描述：强调使用纯函数、避免共享状态和副作用的原则，减少了并发编程中的复杂性。有助于构建更加稳定和可预测的系统。
      适用场景：特别适合于并发处理、大数据分析以及任何需要高度可靠性和一致性的场景。
      优点：代码清晰性， 模块化， 不可变性
      与ddd的区别
          关注点不同：
             FP主要关注的是如何编写代码以实现更高效、更可靠的程序执行，特别是通过避免副作用和利用不可变数据结构来简化并发编程。
             DDD则侧重于理解和建模业务领域本身，旨在创建能够准确反映业务规则和流程的软件系统。
          适用场景不同：
             FP更适合于计算密集型任务或需要高度并行化的环境。
             DDD更适合于需要深入理解复杂业务逻辑的企业级应用开发。
          方法论差异：
             FP是一种编程范式，它提供了一套关于如何组织代码的原则和技术。
             DDD是一种设计方法论，它提供了如何分析业务领域、识别关键概念以及如何将这些概念转化为软件模型的指南。
    2.3.6 微内核架构
       描述: 微内核架构也被称为插件架构，它将最小化的基础框架与扩展功能分离。核心系统提供基本的服务，而额外的功能则通过插件或扩展实现。
       优点: 极大地提高了系统的灵活性和可扩展性，使得可以在不影响核心系统的情况下添加新功能。
       示例: 操作系统设计（如Windows NT）、IDE（集成开发环境）允许用户安装各种插件来增强功能。

  选择哪种方法取决于项目的具体需求、团队的经验和技术栈等因素。例如，如果你的工作主要集中在简化现有系统而不是重新设计整个架构，那么优化单体架构可能是最直接的选择。相反，如果目标是创建一个高度灵活、易于扩展的新系统，那么采用微服务结合DDD或其他现代架构模式可能会更适合。重要的是评估各种选项，并选择最适合你具体情况的方法。
3.技术细节：如果空间允许，提供一点关于如何进行拆分的技术细节可能会很有帮助。比如，是否引入了新的数据库模式，或者是否对某些服务进行了特别的优化等。


### 经典的业务场景。
>>> 这些场景通常涉及到不同的技术栈和解决方案. 了解业务场景的核心需求是做出明智技术决策的前提
Java Web开发常见业务场景：

秒杀系统（高并发场景）：需要处理大量用户同时访问的情况，保证系统的稳定性和响应速度。
订单管理系统：涉及订单的创建、查询、修改和取消等操作，要求数据的一致性和准确性。
支付系统：确保交易的安全性、可靠性和一致性，支持多种支付方式。
物流 & 供应链管理：跟踪货物状态，优化配送路线，提高供应链效率。
会员系统 & 营销活动：管理用户信息，提供个性化服务，实施营销策略。
推荐系统


抽针系统： 针对不同的eventId， 允许客户自定义String 到 json的反序列化。  激励系统执行event前，先调用抽针系统，来获取具体参数json，再根据激励规则获取参数，执行dsl。


元数据管理系统， 策略系统